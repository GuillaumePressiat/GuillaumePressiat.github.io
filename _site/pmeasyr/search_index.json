[
["index.html", "Traitement des données PMSI avec R 1 Introduction", " Traitement des données PMSI avec R Guillaume Pressiat || SIMAP / DOMU / Assistance Publique - Hôpitaux de Paris 2017-06-18 1 Introduction Ce livret numérique présente des exemples de traitements de données PMSI avec R. L’objectif est de concentrer ici : une documentation permettant de débuter avec l’import de données via le package pmeasyr des exemples d’analyses PMSI : requêtes sur les diagnostics et les actes analyse des files actives pour une pathologie statistiques élementaires sur des variables du PMSI analyse du case-mix et de la dms par ghm "],
["contexte.html", "2 Contexte et motivations 2.1 Avantages de R 2.2 Contenu du package 2.3 Installation du package", " 2 Contexte et motivations Les données du Programme de Médicalisation des Systèmes d’Information (PMSI) sont souvent traitées via des logiciels spécifiques au PMSI (ou des outils statistiques / bases de données du marché) ne permettant pas de réaliser des traitements statistiques et des infographies satisfaisantes. Les départements d’information médicale sont donc souvent amenés à retraiter ces données avec R. L’évolution récente de R intègre la manipulation de bases de données de taille importante. Le package pmeasyr s’inscrit dans cette veine et permet de réaliser de façon autonome l’ensemble des traitements (de l’import des données à leur analyse) avec R. 2.1 Avantages de R 2.1.1 Un flux de travail unique En travaillant uniquement avec R, on peut mettre en place un flux de travail épuré : un seul projet, un seul programme, un seul logiciel. La traçabilité, la reproductibilité et la mise à jour des opérations sont ainsi facilitées. Le travail avec de multiples logiciels oblige à l’export / import de fichiers entre les différents logiciels, et chaque modification du début du flux de travail génère des fichiers exportés v1, v2, … Avec un flux complet dans R, toute nouvelle modification est intégrée au processus de travail global. La localisation de toutes les étapes d’une analyse en un seul point évite les erreurs et la confusion lorsque l’on reprend l’analyse ultérieurement. 2.1.2 R et le PMSI L’utilisation de R confère aux données du PMSI la liberté proposée par le logiciel : les requêtes sur les diagnostics et les actes peuvent s’écrire de multiples façons et c’est l’utilisateur qui crée ses propres programmes les données sont dans R : prêtes pour des modèles linéaires, logistiques, des classifications… la confrontation des données in* (reflet du codage des établissements) aux données out* (reflet de la valorisation accordée à l’établissement) est facilitée par l’import du fichier tra, cela peut permettre aux équipes DIM d’améliorer leur recueil le reporting de l’activité en excel, pdf, word, html, ou en créant des applications (shiny) l’utilisation des graphiques pour représenter des volumes d’activités et des cartographies interactives pour visualiser la localisation d’activités, de patientèles, et les flux de patients le partage de projets RStudio, qui facilite et encourage les travaux en équipe. NB: Données In / Out : données en entrée / sortie des logiciels de l’ATIH 2.1.3 Des outils performants L’engouement autour de R est lié au développement de packages intuitifs et performants : readr, dplyr, tidyr, magrittr, pour n’en citer que quelques-uns. pmeasyr s’appuie sur ces packages pour proposer des imports de données rapides sur des fichiers de taille importante (l’entité juridique de l’AP-HP est prise en charge sans problème avec un ordinateur récent). Dans le cas de pmeasyr, l’import de 100 000 rsa (partie fixe, parsing des passages unités médicales, des diagnostics associés et des actes) nécessite en moyenne 5 secondes avec un processeur i7 – 16Go de ram. En dernier ressort, R travaillant en mémoire vive, les exécutions de requêtes sont très rapides. 2.2 Contenu du package Le package contient des fonctions pour la gestion des archives PMSI en entrée / sortie des logiciels de l’ATIH : dézippage, suppression des archives, et des fonctions pour l’import des fichiers des champs PMSI MCO, SSR, HAD, PSY et RSF. Il est utilisé depuis un an à l’AP-HP pour des analyses d’activité et la description des prises en charge. 2.3 Installation du package devtools::install_github(&#39;IM-APHP/pmeasyr&#39;) Cette commande lance l’installation du package et de ses dépendances. "],
["archives.html", "3 Les archives PMSI 3.1 Arborescence des archives 3.2 Informations sur les archives 3.3 Dézippage 3.4 Suppression", " 3 Les archives PMSI Cette partie aborde le point de départ des études PMSI : les archives PMSI. Ces archives sont les fichiers en entrées / sorties des logiciels de l’ATIH. Les manuels techniques de ces logiciels, relatifs aux champs MCO, SSR, HAD, PSY et RSF, respectivement Genrsa, Genrha, Paprica, Pivoine et Preface sont disponibles dans l’espace de téléchargement sur le site de l’ATIH. 3.1 Arborescence des archives Le package pmeasyr prend en charge les données des quatre champs PMSI MCO, SSR, HAD, PSY ainsi que les RSF. Placer les archives dans un répertoire, par exemple ici dans ~/Documents/data/mco : Archives MCO Vous noterez que pour chaque champ PMSI il est conseillé d’utiliser un répertoire indépendant, ceci est nécessaire dans la mesure où le nom des archives PMSI ne contient pas l’information champ MCO, RSF, etc., il faut organiser l’archivage champ par champ, dans des répertoires différents. Un répertoire par champ PMSI # Créer l&#39;arborescence à partir de R champs = c(&#39;mco&#39;, &#39;ssr&#39;, &#39;had&#39;, &#39;psy&#39;, &#39;rsf&#39;) emplacement &lt;- &quot;~/Documents/data&quot; sapply(champs, function(x){dir.create(file.path(emplacement, x))}) 3.2 Informations sur les archives Le nom des fonctions dont l’objectif est de manipuler les archives commence par a. La fonction astat permet d’éditer des statistiques sommaires sur les fichiers contenus dans une archive. Nom Fonction astat ~ *.zip - Liste et volume des fichiers d’une archive PMSI # Informations sur les fichiers : Date de creation, Taille pmeasyr::astat(path = &#39;~/Documents/data/mco/&#39;, file = &#39;750100042.2015.12.29012016174032.out.zip&#39;, view = F) 3.3 Dézippage Cette partie du package facilite la manipulation des archives PMSI, fichiers de type : finess.annee.mois.date_et_heure_de_creation.in.zip finess.annee.mois.date_et_heure_de_creation.out.zip Les fonctions permettent de dézipper les fichiers depuis R en ligne de commande, sans intervention manuelle de l’utilisateur. L’avantage est d’obtenir un processus ne relevant pas d’interventions externes au logiciel R (pour pouvoir garder trace des etapes, et faciliter la reproduction, tout est inscrit dans un programme, dans un flux de processus). Une fois que les traitements et analyses sur les fichiers sont faits, il est possible d’effacer les archives également en ligne de commande. Nom Fonction adezip ~ *.zip - Dezippe des fichiers de larchive PMSI adezip2 ~ *.zip - Dezippe des fichiers de l’archive PMSI, avec en parametre le nom de l’archive # Dezippage uniquement des fichiers rsa, ano et tra du out 2015 # Ex: 750100042.2015.12.20160130.153012.out.zip pmeasyr::adezip(finess = 750100042, annee = 2015, mois = 12, path = &#39;~/Documents/data/mco&#39;, liste = c(&quot;rsa&quot;, &quot;ano&quot;, &quot;tra&quot;), type = &quot;out&quot;) Après éxécution de adezip() sur des fichiers du out # Dezippage uniquement des fichiers rss, dmi et med du in 2015 # Ex: 750100042.2015.12.20160130.153012.out.zip pmeasyr::adezip(finess = 750100042, annee = 2015, mois = 12, path = &#39;~/Documents/data/mco&#39;, liste = c(&quot;rss&quot;, &quot;dmi&quot;, &quot;med&quot;), type = &quot;in&quot;) Après éxécution de adezip() sur des fichiers du in 3.4 Suppression À la fin d’une étude, il est inutile de garder les fichiers dézippés hors de l’archive, on peut les effacer : c’est ce que permet la fonction adelete(). # Effacer les fichiers pmeasyr::adelete(finess = 750100042, annee = 2015, mois = 12, path = &#39;~/Documents/data/mco&#39;, liste = c(&quot;rsa&quot;, &quot;ano&quot;, &quot;tra&quot;), type = &quot;out&quot;) pmeasyr::adelete(finess = 750100042, annee = 2015, mois = 12, path = &#39;~/Documents/data/mco&#39;, liste = c(&quot;rss&quot;, &quot;med&quot;, &quot;dmi&quot;), type = &quot;in&quot;) Après éxécution de adelete() "],
["import-des-donnees.html", "4 Import des données 4.1 MCO 4.2 HAD 4.3 SSR 4.4 PSY 4.5 RSF 4.6 Dictionnaire de variables 4.7 Labels", " 4 Import des données 4.1 MCO Nom Fonction irsa ~ MCO - Import des RSA irum ~ MCO - Import des RUM idiap ~ MCO - Import des DIAP idmi_mco ~ MCO - Import des DMI iium ~ MCO - Import des donnees UM ileg_mco ~ MCO - Import des erreurs Leg imed_mco ~ MCO - Import des Med ipo ~ MCO - Import des PO iano_mco ~ MCO - Import des Anohosp Les données in / out sont prises en charge. 4.1.1 RSA Selon la nature des analyses à produire, plusieurs types d’imports sont possibles : Type Import 1 Light : Partie fixe 2 Light+ : Partie fixe + stream en ligne (+) actes et das 3 Light++ : Partie fixe + stream en ligne (++) actes, das, typaut um et dpdr des um 4 Standard : Partie fixe + creation des tables actes, das et rsa_um 5 Standard+ : Partie fixe + creation des tables actes, das et rsa_um + stream (+) 6 Standard++ : Partie fixe + creation des tables actes, das et rsa_um + stream (++) library(pmeasyr) # Import des rsa 2015 type 6 irsa(finess = 750100042, annee = 2015, mois = 12, path = &#39;~/Documents/data/mco&#39;, typi = 6) -&gt; rsa15 View(rsa15$rsa) View(rsa15$rsa_um) View(rsa15$actes) View(rsa15$das) Les tables sont par défaut avec des libellés : Capture d’une portion de la table rsa15$rsa 4.1.2 RUM # Import des rum 2015 irum(finess = 750100042, annee = 2015, mois = 12, path = &#39;~/Documents/data/mco&#39;) Selon la nature des analyses à produire, plusieurs types d’imports sont possibles : Type Import 1 XLight : Partie fixe 2 Light : Partie fixe + stream en ligne des actes, das et dad 3 Standard : Partie fixe + table actes, das, dad 4 Standard+ : Partie fixe + stream + table actes, das, dad 4.1.3 Colonnes stream Exemples sur quelques rsa : actes : Actes CCAM du Rsa Cle RSA actes 0000000001 EDSF004, EDSF004, JQGA004, JQGA004 0000000002 EPLF002, DEQP003, DEQP007, DZQM006 0000000003 EBQH002, EEQH002, YYYY180 dpdrum : zones diagnostics des passages UM du Rsa Cle RSA dpdrum 0000000004 Z098 I671 0000000005 Z380, P741, Z380 das : zones diagnostics associes du Rsa Cle RSA das 0000000006 Z9580, Z9588 0000000007 P011, P032, P036, P011, P032, P700, P011, P032, P036 um : types autorisations T2A des um de passage par ordre chronologique Cle RSA um 0000000009 01AC, 53 C 0000000010 51 C 0000000011 71 C, 04 C, 71 C Capture des zones stream de la table rsa15$rsa Pour les quatre autres champs PMSI, seules les données du out sont prises en charge par le package pour le moment. Les fonctions d’imports pour ces champs PMSI reposent sur le même principe qu’en MCO. 4.2 HAD Nom Fonction iano_had ~ HAD - Import des Anohosp imed_had ~ HAD - Import des Med irapss ~ HAD - Import des RAPSS ileg_had ~ HAD - Import des erreurs LEG library(pmeasyr) # Import des rapss 2015 irapss(finess = 750712184, annee = 2015, mois = 12, path = &#39;~/Documents/data/had&#39;) -&gt; data_had 4.3 SSR Nom Fonction iano_ssr ~ SSR - Import des Anohosp irha ~ SSR - Import des RHA issrha ~ SSR - Import des SSRHA imed_ssr ~ SSR - Import des MED iium_ssr ~ SSR - Import des UM ileg_ssr ~ SSR - Import des erreurs LEG # Import des rha 2015 irha(finess = 750041543, annee = 2015, mois = 12, path = &#39;~/Documents/data/ssr&#39;) -&gt; data_ssr 4.4 PSY Nom Fonction iano_psy ~ PSY - Import des Anohosp ir3a ~ PSY - Import des R3A irpsa ~ PSY - Import des RPSA # Import des rpsa 2015 irpsa(finess = 750803454, annee = 2015, mois = 12, path = &#39;~/Documents/data/psy&#39;) -&gt; rpsa_psy # Import des r3a 2015 ir3a(finess = 750803454, annee = 2015, mois = 12, path = &#39;~/Documents/data/psy&#39;) -&gt; r3a_psy 4.5 RSF Nom Fonction irafael ~ RSF - Import des RSFA / Rafael iano_rafael ~ RSF - Import des RSFA / ANO # Import des rsfa 2015 irafael(finess = 750712184, annee = 2015, mois = 12, path = &#39;~/Documents/data/rsf&#39;) -&gt; rsfa 4.6 Dictionnaire de variables # Obtenir les noms, labels et types de variables (character, numeric, integer, date, ...) dico(rsa15$rsa) # Charger les formats de toutes les tables prises en charge par le package pmeasyr::formats 4.7 Labels # Obtenir le libelle d&#39;une variable du PMSI labeleasier(rsa15$rsa$SEXE, Sexe = T) labeleasier(rsa15$rsa$ECHPMSI, Mode_entree = T) "],
["requetes-sur-des-pathologies-actes.html", "5 Requêtes sur des pathologies / actes 5.1 Transposition des codes diagnostics 5.2 Recherche de codes diagnostics 5.3 Recherche de codes actes", " 5 Requêtes sur des pathologies / actes 5.1 Transposition des codes diagnostics Les analyses sur les diagnostics CIM-10 sont parfois fastidieuses du fait des multiples positions de diagnostics : DP principal du séjour, DR principal du séjour, DPUM, DRUM, DAS. La fonction tdiag permet de rassembler tous les diagnostics dans une seule table. # Pour les objets rsa et rum du MCO # Transbahuter tous les diagnostics dans une seule table tdiag(rsa15) -&gt; rsa15 # &quot;Tidy diagnostics&quot; View(rsa15$diags) # Tous les diagnostics sont dans une table, avec un numero selon leur position # 1:DP, 2:DR, 3:DPUM, 4:DRUM, 5:DAS Exemple de résultat : CLE_RSA NSEQRUM position diag 0000000001 01 1 Z511 0000000001 01 2 C18 0000000002 01 1 C501 0000000002 01 3 C501 0000000002 02 1 D051 0000000002 02 5 E109 5.2 Recherche de codes diagnostics L’objectif est de récupérer les séjours présentant un code diagnostic de la liste # Liste D-0103 de la fonction groupage 2016 : Epilepsies liste_diag = c(&#39;F803&#39;, &#39;G400&#39;, &#39;G401&#39;, &#39;G402&#39;, &#39;G403&#39;, &#39;G404&#39;, &#39;G405&#39;, &#39;G406&#39;, &#39;G407&#39;, &#39;G408&#39;, &#39;G409&#39;, &#39;G410&#39;, &#39;G411&#39;, &#39;G412&#39;, &#39;G418&#39;, &#39;G419&#39;, &#39;R568&#39;) # En passant par la table diags tdiag(rsa15) -&gt; rsa15 library(dplyr) # quelle que soit la position du diagnostic rsa15$diags %&gt;% filter(diag %in% liste_diag) # position en das rsa15$diags %&gt;% filter(diag %in% liste_diag, position == 5) # position en dp dr rsa15$diags %&gt;% filter(diag %in% liste_diag, position &lt; 5) # En passant par les zones stream string_diags = &#39;F803|G400|G401|G402|G403|G404|G405|G406|G407|G408|G409|G410|G411|G412|418|G419|R568&#39; # quelle que soit la position du diagnostic rsa15$rsa %&gt;% fiter(grepl(string_diags, dpdrum)|grepl(string_diags, das)) # position en das rsa15$rsa %&gt;% fiter(grepl(string_diags, das)) # position en dpdr rsa15$rsa %&gt;% fiter(grepl(string_diags, dpdrum)) 5.3 Recherche de codes actes # Code EBLA003 library(dplyr) # En passant par la table actes rsa15$actes %&gt;% filter(CDCCAM == &#39;EBLA003&#39;) # En passant par la zone stream rsa15$rsa %&gt;% filter(grepl(&#39;EBLA003&#39;, actes)) "],
["etude-des-files-actives.html", "6 Étude des files actives 6.1 Import des données Anohosp 6.2 File active d’une pathologie 6.3 File active d’une chirurgie", " 6 Étude des files actives 6.1 Import des données Anohosp # Import des données anohosp du out iano_mco(finess = 750100042, annee = 2015, mois = 12, path = &#39;~/Documents/data/mco&#39;) -&gt; ano # Filtrer sur les patients chainables avec la variable cok library(dplyr) ano %&gt;% filter(cok) -&gt; ano # File active globale établissement distinct(ano, NOANON) %&gt;% nrow() 6.2 File active d’une pathologie # Codes diagnostics obésité string_diags = &#39;E66&#39; library(dplyr) # position en dpdr rsa15$rsa %&gt;% filter(grepl(string_diags, dpdrum)) -&gt; ob # File active obésité globale établissement inner_join(ano, ob, by = c(&#39;CLE_RSA&#39;)) -&gt; patients_ob distinct(patients_ob, NOANON) %&gt;% nrow() 6.3 File active d’une chirurgie # Codes actes chirurgie bariatrique liste_actes = c(&#39;HFCA001&#39;, &#39;HFCC003&#39;, &#39;HFFC004&#39;, &#39;HFFA001&#39;, &#39;HFMA009&#39;, &#39;HFMC007&#39;, &#39;HFKA001&#39;, &#39;HFKC001&#39;, &#39;HFKA002&#39;, &#39;HFMA011&#39;, &#39;HFMC008&#39;, &#39;HFMA010&#39;, &#39;HFMC006&#39;, &#39;HFLE002&#39;, &#39;HFGC900&#39;, &#39;HFLC900&#39;, &#39;HFFA011&#39;, &#39;HFFC018&#39;, &#39;HGCA009&#39;, &#39;HGCC027&#39;) library(dplyr) # acte codé activité 1 (chirurgical) rsa15$actes %&gt;% filter(CDCCAM %in% liste_actes, ACT == &#39;1&#39;) -&gt; cob # File active chirurgie bariatrique globale établissement inner_join(ano, cob, by = c(&#39;CLE_RSA&#39;)) -&gt; patients_cob distinct(patients_cob, NOANON) %&gt;% nrow() "],
["fichier-tra.html", "7 Fichier TRA 7.1 Ajout du TRA en MCO 7.2 Ajout du TRA en HAD 7.3 Ajout du TRA en SSR 7.4 Ajout du TRA en PSY", " 7 Fichier TRA Le fichier TRA est un fichier du out qui permet de relier les données anonymes du out aux données du in, il comprend un lien entre : MCO : clé rsa, numéro de rss, numéro de sejour (nas), date d’entrée et date de sortie du séjour SSR : numéro séquentiel du séjour + noseqrhs et numéro de séjour + numéro de semaine PSY RPSA : ipp, date d’entrée et de fin du sejour, numéro séquentiel du séjour, numéro de séquence et numéro de séjour, dates de début et fin de sequence PSY R3A : ipp, date de l’acte, numéro d’ordre, forme activité, um, nature et lieu de l’acte HAD : numéro séquentiel de séjour, numéro de séquence, sous-sequence et numéro de séjour, dates de début et fin des séquences et sous-séquences, dates d’entrée et de sortie du séjour, modes d’entrée sortie provenance destination Type Import itra ~ TRA - Import du TRA inner_tra ~ TRA - Ajout du TRA aux données Out 7.1 Ajout du TRA en MCO # lecture du fichier tra et jointure aux rsa itra(750100042, 2015, 12, &#39;~/Documents/data/mco&#39;) -&gt; tra # Ajout du tra aux rsa : inner_tra(rsa15$rsa, tra) -&gt; rsa15$rsa # Ajout du tra à la partie um des rsa : inner_tra(rsa15$rsa_um, tra) -&gt; rsa15$rsa_um # Ajout du tra à la partie actes des rsa : inner_tra(rsa15$actes, tra) -&gt; rsa15$actes # Ajout du tra à la partie das des rsa : inner_tra(rsa15$das, tra) -&gt; rsa15$das 7.2 Ajout du TRA en HAD # Import du TRA HAD itra(finess = 750712184, annee = 2015, mois = 12, path = &#39;~/Documents/data/had&#39;, champ = &quot;had&quot;) -&gt; tra # Ajout du tra inner_tra(data_had$rapss, tra, champ = &quot;had&quot;) -&gt; data_had$rapss inner_tra(data_had$acdi, tra, champ = &quot;had&quot;) -&gt; data_had$acdi inner_tra(data_had$ght, tra, champ = &quot;had&quot;) -&gt; data_had$ght 7.3 Ajout du TRA en SSR # Import du TRA SSR itra(finess = 750712184, annee = 2015, mois = 12, path = &#39;~/Documents/data/ssr&#39;, champ = &quot;ssr&quot;) -&gt; tra # Ajout du tra inner_tra(data_ssr$rha, tra, champ = &quot;ssr&quot;) -&gt; data_ssr$rha inner_tra(data_ssr$acdi, tra, champ = &quot;ssr&quot;) -&gt; data_ssr$acdi 7.4 Ajout du TRA en PSY # Import du TRA PSY : fichiers RPSA itra(finess = 750803454, annee = 2015, mois = 12, path = &#39;~/Documents/data/psy&#39;, champ = &quot;tra_psy_rpsa&quot;) -&gt; tra # Ajout du tra inner_tra(rpsa_psy$rpsa, tra, champ = &quot;psyrpsa&quot;) -&gt; rpsa_psy$rpsa inner_tra(rpsa_psy$das, tra, champ = &quot;psyrpsa&quot;) -&gt; rpsa_psy$das # Import du TRA PSY : fichiers R3A itra(finess = 750803454, annee = 2015, mois = 12, path = &#39;~/Documents/data/psy&#39;, champ = &quot;tra_psy_r3a&quot;) -&gt; tra # Ajout du tra inner_tra(r3a_psy$r3a, tra, champ = &quot;psyr3a&quot;) -&gt; r3a_psy$r3a inner_tra(r3a_psy$das, tra, champ = &quot;psyr3a&quot;) -&gt; r3a_psy$das "],
["statistiques-du-pmsi.html", "8 Statistiques du PMSI 8.1 Âge et durée de séjour 8.2 Nombre de séjours par catégorie majeure de diagnostics 8.3 Case-mix MCO, DMS par GHM / GHS", " 8 Statistiques du PMSI 8.1 Âge et durée de séjour library(dplyr) # Age moyen et DMS sur les plus de 0 jour rsa15$rsa %&gt;% summarise(age_moyen = mean(AGEAN, na.rm = T), dms = mean(DUREE[DUREE &gt; 0]), effectif = n(), effectif_sup0 = sum(DUREE &gt; 0)) # Age moyen en prenant en compte les séjours des bébés # (variable age en jour) rsa15$rsa %&gt;% mutate(Age = if_else(is.na(AGEAN), as.integer(AGEJR) / 365.25, as.numeric(AGEAN))) %&gt;% summarise(age_moyen = mean(Age), effectif = n()) 8.2 Nombre de séjours par catégorie majeure de diagnostics # Nombre de séjours par catégorie majeure de diagnostics rsa15$rsa %&gt;% count(RSACMD) 8.3 Case-mix MCO, DMS par GHM / GHS # Construire la variable GHM rsa15$rsa %&gt;% tidyr::unite(GHM, RSACMD, RSATYPE, RSANUM, RSACOMPX, sep = &quot;&quot;) -&gt; rsa15$rsa # Case-mix par GHM rsa15$rsa %&gt;% count(GHM) # Case-mix par GHM / GHS rsa15$rsa %&gt;% count(GHM, NOGHS) # DMS par GHM / GHS rsa15$rsa %&gt;% group_by(GHM, NOGHS) %&gt;% summarise(dms = mean(DUREE[DUREE &gt; 0]), effectif = n(), effectif_sup0 = sum(DUREE &gt; 0)) "],
["help.html", "9 Help", " 9 Help Toutes les fonctions du package ont une page d’aide : # Exemple : aide sur la fonction d&#39;import des rsa ?irsa L’aide en ligne est disponible ici. "]
]
